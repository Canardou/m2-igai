<!DOCTYPE html>
<html>
    <head>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="css/tacit-css-1.1.1.css"/>
        <script id="vertexShader" type="x-shader/x-vertex">
        uniform mat4 uBonesTransformation[ BONES ];
        
        varying vec3 vNormal;
        attribute vec4 bones;
        attribute vec4 weights;
        
        void main() {
            vNormal = vec3(weights[0],weights[1],0.0);
            vec4 wPosition = vec4(0.0);
            
            for (int i = 0; i < 4; i++) {
                wPosition += weights[i] * (
                                uBonesTransformation[ int(bones[i]) ] *
                                vec4( position, 1.0));
            }
            mat4 mv = projectionMatrix * 
                        modelViewMatrix;
            gl_Position =  mv * wPosition;
        }
        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vNormal;
        
        void main() {
            gl_FragColor = vec4(vNormal.x*.5+.5,vNormal.y*.5+.5,vNormal.z*.5+.5,1.0);
        }
        </script>
        <script src="scripts/three.min.js"></script>
        <script src="scripts/trackball.js"></script>
        <script src="scripts/subdivise/generateLookups.js"></script>
    </head>
    <body>
		<section><article>
        <h1>Bones</h1>
        
        <div id="scene"></div>
        <em>Variables : t</em><br>
        <table>
            <tr>
                <th>
                    Axis
                </th>
                <th>
                    Parent (Red)
                </th>
                <th>
                    Child (Green)
                </th>
            </tr>
            <tr>
                <th>
                    X
                </th>
                <td>
                    <input type="text" id="PX" value="0"></input>
                </td>
                <td>
                    <input type="text" id="CX" value="0"></input>
                </td>
            </tr>
            <tr>
                <th>
                    Y
                </th>
                <td>
                    <input type="text" id="PY" value="0"></input>
                </td>
                <td>
                    <input type="text" id="CY" value="0"></input>
                </td>
            </tr>
            <tr>
                <th>
                    Z
                </th>
                <td>
                    <input type="text" id="PZ" value="0"></input>
                </td>
                <td>
                    <input type="text" id="CZ" value="t"></input>
                </td>
            </tr>
        </table>
	    </article></section>
    </body>
</html>
<script>
    
    /*global THREE*/
    
    var bufferGeometry = new THREE.CylinderBufferGeometry( 1, 1, 10, 16, 8 );

    var scene = new THREE.Scene();
    var bonesScene = new THREE.Scene();

    var renderer = new THREE.WebGLRenderer();
    renderer.autoClear = false;

    renderer.setSize(700, 400);
    
    var domElem = document.getElementById("scene").appendChild(renderer.domElement);
    
    var camera = new THREE.PerspectiveCamera(40, 700 / 400, 0.1, 15000);
    camera.position.set(0, 0, 20);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    
    //var object = new THREE.Mesh( geometry, material );
    
    //var geo = new THREE.WireframeGeometry( geometry); // or WireframeGeometry
    //var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2} );
    //var wireframe = new THREE.LineSegments( geo, mat );
    
    class Bone{
       constructor(x,y,z,xd,yd,zd,r,color){
           this.position = new THREE.Vector3(x,y,z);
           this.transformation = (new THREE.Matrix4()).identity();
           this.parent = null;
           //Weight calculation
           this.center = new THREE.Vector3(xd,yd,zd);
           this.radius = r;
           this.color = color;
       }
       
       getArrow(){
           return new THREE.ArrowHelper(new THREE.Vector3().subVectors(this.position,this.center).normalize(),this.position, this.position.distanceTo(this.center), this.color )
       }
       
       getSphere(){
            var sphereGeom = new THREE.SphereGeometry( this.radius, 32, 32 );
            var blueMaterial = new THREE.MeshBasicMaterial( { color: this.color, transparent: true, opacity: 0.5 } );
            var mesh = new THREE.Mesh( sphereGeom, blueMaterial );
            mesh.translateX(this.center.x);
            mesh.translateY(this.center.y);
            mesh.translateZ(this.center.z);
            return mesh;
       }
       
       getPosition(){
           //Position shouldn't change
           return this.position;
       }
       
       getTransformation(){
           //Should take into account parent
           var transformation = this.transformation.clone();
           transformation.multiply(new THREE.Matrix4().makeTranslation(-this.position.x,-this.position.y,-this.position.z));
           
           if(this.parent != null){
                var translation = new THREE.Matrix4().makeTranslation(this.position.x-this.parent.position.x,this.position.y-this.parent.position.y,this.position.z-this.parent.position.z);
                var translation2 = new THREE.Matrix4().makeTranslation(this.parent.position.x,this.parent.position.y,this.parent.position.z);
                var transformationClone = this.parent.getTransformation();
                return translation2.multiply(translation.multiply(transformationClone)).multiply(transformation);
           }
           return transformation;
       }
    }
    
    var bonesGeometry = [];
    var tmp_bone = new Bone(0,0,0,0,5.1,0,5,0x00ff00);
    //need 4 bones minimum
    tmp_bone.parent = new Bone(0,5.1,0,0,10.2,0,5,0xff0000);
    tmp_bone.parent.parent =new Bone(0,0,0);
    bonesGeometry.push(tmp_bone.parent);
    bonesGeometry.push(tmp_bone);
    bonesGeometry.push(tmp_bone.parent.parent);
    bonesGeometry.push(new Bone(0,0,0));
    
    bonesScene.add(tmp_bone.getArrow())
    bonesScene.add(tmp_bone.parent.getArrow())
    
    var uBonesPosition = [];
    var uBonesTransformation = [];
    for(var k in bonesGeometry){
        uBonesPosition.push(bonesGeometry[k].position);
        uBonesTransformation.push(bonesGeometry[k].getTransformation());
    }
    
    var material = new THREE.ShaderMaterial({
        defines: {
        	BONES: bonesGeometry.length
        },
        uniforms: {
            uBonesPosition: { type: "v3v", value: uBonesPosition },
            uBonesTransformation: { type: "m4v", value: uBonesTransformation }
        },
    	vertexShader: document.getElementById( 'vertexShader' ).textContent,
    	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    });
    
     
    var vertices = bufferGeometry.attributes.position;
    var bones = [];
    var weights = [];
    
    for(var i = 0; i < vertices.count; i++){
        if(vertices.getY(i) > 2)
            weights = weights.concat([1,0,0,0]); 
        else if(vertices.getY(i) < -2)
            weights = weights.concat([0,1,0,0]); 
        else {
            var tmp = (vertices.getY(i)+2)/4;
            weights = weights.concat([tmp,1-tmp,0,0])
        }
        bones = bones.concat([0,1,0,0]);
    }
    bones = new Uint8Array(bones);
    weights = new Float32Array(weights);
    
    // itemSize = 3 because there are 3 values (components) per vertex
    bufferGeometry.addAttribute( 'weights', new THREE.BufferAttribute( weights, 4) );
    bufferGeometry.addAttribute( 'bones', new THREE.BufferAttribute( bones, 4) );
    
    var mesh = new THREE.Mesh( bufferGeometry, material );
    
    scene.add(mesh);
    //scene.add(wireframe);
        
    var camControls = new THREE.TrackballControls( camera, domElem );
	camControls.rotateSpeed = 5.0;
	camControls.zoomSpeed = 1.2;
	camControls.panSpeed = 0.8;
	camControls.noZoom = false;
	camControls.noPan = false;
	camControls.staticMoving = true;
	camControls.dynamicDampingFactor = 0.3;
	camControls.keys = [ 65, 83, 68 ];
	camControls.addEventListener( 'change', render );
    
    var clock = new THREE.Clock();
    
    (function animloop(){
      requestAnimationFrame(animloop);
      camControls.update(clock.getDelta());
      render();
      var t = clock.getElapsedTime();
      
      bonesGeometry[0].transformation.makeRotationX(eval(document.getElementById("PX").value));
      bonesGeometry[0].transformation.multiply(new THREE.Matrix4().makeRotationY(eval(document.getElementById("PY").value)));
      bonesGeometry[0].transformation.multiply(new THREE.Matrix4().makeRotationZ(eval(document.getElementById("PZ").value)));
      
      bonesGeometry[1].transformation.makeRotationX(eval(document.getElementById("CX").value));
      bonesGeometry[1].transformation.multiply(new THREE.Matrix4().makeRotationY(eval(document.getElementById("CY").value)));
      bonesGeometry[1].transformation.multiply(new THREE.Matrix4().makeRotationZ(eval(document.getElementById("CZ").value)));
      
      uBonesTransformation[0] = bonesGeometry[0].getTransformation();
      uBonesTransformation[1] = bonesGeometry[1].getTransformation();
    })();
    
    function render(){
        renderer.clear();
		renderer.render( scene, camera );
		renderer.clearDepth();
		renderer.render( bonesScene, camera );
    }
</script>