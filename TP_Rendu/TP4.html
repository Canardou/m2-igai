<!DOCTYPE html>
<html>
    <head>
        <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        
        void main() {
            vNormal = normal;
            
            gl_Position =   projectionMatrix * 
                            modelViewMatrix * 
                            vec4(position,1.0);
        }
        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vNormal;
        
        void main() {
            gl_FragColor = vec4(vNormal.x*.5+.5,vNormal.y*.5+.5,vNormal.z*.5+.5,1.0);
        }
        </script>
        <script src="three.min.js"></script>
        <script src="trackball.js"></script>
        <script src="TP4/marching_cube.js"></script>
        <script src="TP4/sphere_implicit.js"></script>
        <script src="TP4/plan_implicit.js"></script>
        <script src='subdivise.js'></script>
    </head>
    <body>
        <h1>Implicit Surface</h1>
        Seuil <input type=range min=0.02 value=0 max=2 step=0.02 onchange="changeSeuil(this.value)" value="0.5"><span id=value>0.5</span><br>
    </body>
</html>
<script>
    var seuil = 0.5;
    function changeSeuil(value){
        seuil = value;
        document.getElementById("value").innerHTML = seuil;
    }
    
    /*global THREE, sphere*/
    var scene = new THREE.Scene();

    var renderer = new THREE.WebGLRenderer();

    renderer.setSize(screen.width/2, screen.height/2);
    
    document.body.appendChild(renderer.domElement);
    
    var camera = new THREE.PerspectiveCamera(40, screen.width / screen.height, 0.1, 15000);
    camera.position.set(0, 0, 10);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    
    var material = new THREE.ShaderMaterial({
    	vertexShader: document.getElementById( 'vertexShader' ).textContent,
    	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    });
    

    var camControls = new THREE.TrackballControls( camera );
	camControls.rotateSpeed = 5.0;
	camControls.zoomSpeed = 1.2;
	camControls.panSpeed = 0.8;
	camControls.noZoom = false;
	camControls.noPan = false;
	camControls.staticMoving = true;
	camControls.dynamicDampingFactor = 0.3;
	camControls.keys = [ 65, 83, 68 ];
	camControls.addEventListener( 'change', render );
	
	var spheres = [];
	for(var i = 0; i < 3; i++){
	    spheres.push(new sphere(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5,1/5));
	}
	
	var surface = new THREE.Geometry();
	
	const cube = [[0, 0, 0],
	              [1, 0, 0],
	              [1, 1, 0],
	              [0, 1, 0],
	              [0, 0, 1],
	              [1, 0, 1],
	              [1, 1, 1],
	              [0, 1, 1]];
	
	const edges = [[0.5, 0, 0],
	              [1, 0.5, 0],
	              [0.5, 1, 0],
	              [0, 0.5, 0],
	              [0.5, 0, 1],
	              [1, 0.5, 1],
	              [0.5, 1, 1],
	              [0, 0.5, 1],
	              [0, 0, 0.5],
	              [1, 0, 0.5],
	              [1, 1, 0.5],
	              [0, 1, 0.5]];
	              
	const interpol = [[0, 1],
	              [1, 2],
	              [2, 3],
	              [3, 0],
	              [4, 5],
	              [5, 6],
	              [6, 7],
	              [7, 4],
	              [0, 4],
	              [1, 5],
	              [2, 6],
	              [3, 7]];
	              
    const res = 15;
    
    function interpolate(x,y,z,c,vertices,gridValues, interpolations){
        var x1 = Math.max(x+cube[interpol[c][0]][0],x+cube[interpol[c][1]][0]);
        var x2 = Math.min(x+cube[interpol[c][0]][0],x+cube[interpol[c][1]][0]);
        var y1 = Math.max(y+cube[interpol[c][0]][1],y+cube[interpol[c][1]][1]);
        var y2 = Math.min(y+cube[interpol[c][0]][1],y+cube[interpol[c][1]][1]);
        var z1 = Math.max(z+cube[interpol[c][0]][2],z+cube[interpol[c][1]][2]);
        var z2 = Math.min(z+cube[interpol[c][0]][2],z+cube[interpol[c][1]][2]);
        if(interpolations[x1+"_"+y1+"_"+z1+"_"+x2+"_"+y2+"_"+z2]==undefined){
            var index = vertices.length;
            var vect1 = new THREE.Vector3(x/res+cube[interpol[c][0]][0]/res,y/res+cube[interpol[c][0]][1]/res,z/res+cube[interpol[c][0]][2]/res)
            var vect2 = new THREE.Vector3(x/res+cube[interpol[c][1]][0]/res,y/res+cube[interpol[c][1]][1]/res,z/res+cube[interpol[c][1]][2]/res)
            var factor = (seuil - gridValues[interpol[c][0]])/(gridValues[interpol[c][1]] - gridValues[interpol[c][0]]);
            var vect = vect1.add(vect2.sub(vect1).multiplyScalar(factor));
            vertices.push(vect);
            interpolations[x1+"_"+y1+"_"+z1+"_"+x2+"_"+y2+"_"+z2] = index;
            return index;
        }
        else{
            return interpolations[x1+"_"+y1+"_"+z1+"_"+x2+"_"+y2+"_"+z2];
        }
    }
    
    function calculateGrid(x,y,z,res,grid,objects){
        //Slower
        /*if(grid[x+"_"+y+"_"+z]==undefined){
            var value = 0;
            for(var k in objects){
                value += spheres[k].distance(x/res,y/res,z/res);
            }
            grid[x+"_"+y+"_"+z] = value;
            return value;
        }
        else
            return grid[x+"_"+y+"_"+z];*/
        var value = 0;
        for(var k in objects){
            value += spheres[k].distance(x/res,y/res,z/res);
        }
        return value;
    }
    
    function marchingcube(){
        var vertices = [];
    	var faces = [];
    	var interpolations = {};
    	var gridValues = {};
    	
    	var values = [];
        
        for ( var x = -res; x < res; x ++ ) {
            for ( var y = -res; y < res; y ++ ) {
                for ( var z = -res; z < res; z ++ ) {
                    var bitwise = 0;
                    for(var c = 0; c < cube.length; c++){
                        values[c] = calculateGrid(x+cube[c][0],y+cube[c][1],z+cube[c][2],res,gridValues,spheres);
                        if(values[c]<seuil){
                            bitwise |= (1 << c);
                        }
                    }
                    //treat bitwise
                    if(bitwise > 0 && bitwise < 255){
                        var vect = [];
                        
                        for(var c = 0; c < edges.length; c++){
                            if((THREE.edgeTable[bitwise] & 1 << c) > 0)
                                vect[c] = interpolate(x,y,z,c,vertices,values,interpolations);
                        }
                        var i = 0;
                        while ( THREE.triTable[bitwise][i] != -1 && i<16 ) {
                            faces.push(new THREE.Face3(vect[THREE.triTable[bitwise][i]], vect[THREE.triTable[bitwise][i+1]], vect[THREE.triTable[bitwise][i+2]]));
                    		i += 3;
                    	}
                    }
                }
            }
        }
        
        surface.vertices =  vertices;
        surface.faces = faces;
        
        surface.computeVertexNormals();
    }
    
    marchingcube();
    
    var material = new THREE.ShaderMaterial({
    	vertexShader: document.getElementById( 'vertexShader' ).textContent,
    	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    });
    
    var object = new THREE.Mesh( surface, material );
    scene.add(object);
    
    var box =  new THREE.BoxGeometry( 2, 2, 2 );
    var geo = new THREE.EdgesGeometry( box);
    var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1} );
    var wireframe = new THREE.LineSegments( geo, mat );
    scene.add(wireframe);
	
	function updateSphere(time){
	    surface.elementsNeedUpdate = true;
	    time *= 5;
	    for(var k in spheres){
	        spheres[k].x = spheres[k].initial_x + Math.cos(k/3 * time)/4;
	        spheres[k].y = spheres[k].initial_y + Math.sin(k/5 * time/3)/4;
	        spheres[k].z = spheres[k].initial_z + Math.cos(k/4 * time/5)/4;
	    }
	    marchingcube();
	}
    
    var clock = new THREE.Clock();
    
    (function animloop(){
      camControls.update(clock.getDelta());
      updateSphere(clock.getElapsedTime());
      render();
      requestAnimationFrame(animloop);
    })();
    
    function render(){
		renderer.render( scene, camera );
    }
</script>