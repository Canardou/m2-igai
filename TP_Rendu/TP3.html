<!DOCTYPE html>
<html>
    <head>
        <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        
        void main() {
            vNormal = normal;
            
            gl_Position =   projectionMatrix * 
                            modelViewMatrix * 
                            vec4(position,1.0);
        }
        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vNormal;
        
        void main() {
            gl_FragColor = vec4(vNormal.x*.5+.5,vNormal.y*.5+.5,vNormal.z*.5+.5,1.0);
        }
        </script>
        <script src="three.min.js"></script>
        <script src="trackball.js"></script>
        <script src="generateLookups.js"></script>
    </head>
    <body>
        <h1>Loop Subdivision</h1>
    </body>
</html>
<script>
    /*global THREE, BSpline, Surface*/
    var geometry = new THREE.BoxGeometry( 1, 1, 1 );
    //var geometry = new THREE.ConeGeometry( 1, 1, 5 );
    
    geometry.faceVertexUvs = [];
    
    for(var boucle = 0; boucle < 5; boucle++){
        var oldVertices = geometry.vertices; // { x, y, z}
    	var oldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }
    
    	// Generate edges Lookup
    
    	var edges = {}; // edge oldVertex1_oldVertex2 = { oldVertex1, oldVertex2, faces[]  }
        var metaVertices = [];
    
    	generateLookups(oldVertices, oldFaces, metaVertices, edges);
    	
    	// new edges vertex
    	/*
    	    2 6
    	     6 2
    	*/
    	
    	var newEdgeVertices = [];
    
        for(var k in edges){
            var edge = edges[k];
            //R2, R3, R4
            var vertexWeight = 6/16;
            var adjVertexWeight = 2/16;
            
            var newVertex = new THREE.Vector3();
            
            newVertex.add(edge.a).multiplyScalar(vertexWeight);
            newVertex.add(edge.b.clone().multiplyScalar(vertexWeight));
            
            for(var l in edge.faces){
                var face = edge.faces[l];
                
                // each vertex
                var letters = ['a','b','c'];
                
                for(var m in letters){
                    var vertex = oldVertices[face[letters[m]]];
                    if(vertex != edge.a && vertex != edge.b){
                        newVertex.add(vertex.clone().multiplyScalar(adjVertexWeight));
                    }
                }
            }
            edge.newIndex = newEdgeVertices.length+oldVertices.length;
            newEdgeVertices.push(newVertex);
        }
        
        //console.assert(newEdgeVertices.length == 18, "Edges vertex should count to 18");
        
        // Reposition already created vertex
        /*
            1  1  
          1  10  1
            1  1
        */
        var newSourceVertices = [];
        for(var i = 0; i < oldVertices.length; i++){
            var oldVertex = oldVertices[i];
            
            let edges = metaVertices[i].edges;
            var n = edges.length;
            
            var alpha_n = Math.pow(3/8 + Math.cos(2*Math.PI/n)/4, 2)+3/8;
            
            var alpha = 1.7*alpha_n - 1;
            var beta = (1-alpha)/n;
            
            let newVertex = oldVertex.clone().multiplyScalar(alpha);
            for(var k in edges){
                newVertex.add(edges[k].clone().multiplyScalar(beta));
            }
            newSourceVertices.push(newVertex);
        }
        
        //link source and edge -> 1 face = 4 new faces
        var newFaces = [];
        var newVertices = newSourceVertices.concat(newEdgeVertices);
        for(var i = 0; i<oldFaces.length; i++){
            var face = oldFaces[i];
            
            var d = getEdge( face.a, face.b, edges ).newIndex;
            var e = getEdge( face.b, face.c, edges ).newIndex;
            var f = getEdge( face.c, face.a, edges ).newIndex;
            
            /*
                    a
                   / \
                  d---f
                 / \ / \
                b---e---c 
            */
            newFaces.push(new THREE.Face3(d, e, f));
            newFaces.push(new THREE.Face3(face.a, d, f));
            newFaces.push(new THREE.Face3(face.b, e, d));
            newFaces.push(new THREE.Face3(face.c, f, e));
        }
        
        geometry.faces = newFaces;
        geometry.vertices = newVertices;
    }
    geometry.computeVertexNormals();
    
    
    
    var scene = new THREE.Scene();

    var renderer = new THREE.WebGLRenderer();

    renderer.setSize(screen.width/2, screen.height/2);
    
    document.body.appendChild(renderer.domElement);
    
    var camera = new THREE.PerspectiveCamera(40, screen.width / screen.height, 0.1, 15000);
    camera.position.set(0, 0, 4);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    
    var material = new THREE.ShaderMaterial({
    	vertexShader: document.getElementById( 'vertexShader' ).textContent,
    	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    });
    
    var object = new THREE.Mesh( geometry, material );
    
    var geo = new THREE.WireframeGeometry( geometry); // or WireframeGeometry
    var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2} );
    var wireframe = new THREE.LineSegments( geo, mat );
    object.add( wireframe );
    
   scene.add(object);
        
    var camControls = new THREE.TrackballControls( camera );
	camControls.rotateSpeed = 5.0;
	camControls.zoomSpeed = 1.2;
	camControls.panSpeed = 0.8;
	camControls.noZoom = false;
	camControls.noPan = false;
	camControls.staticMoving = true;
	camControls.dynamicDampingFactor = 0.3;
	camControls.keys = [ 65, 83, 68 ];
	camControls.addEventListener( 'change', render );
    
    
    
    
    var clock = new THREE.Clock();
    
    (function animloop(){
      requestAnimationFrame(animloop);
      camControls.update(clock.getDelta());
      render();
    })();
    
    function render(){
		renderer.render( scene, camera );
    }
</script>