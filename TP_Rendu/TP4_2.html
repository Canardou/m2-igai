<!DOCTYPE html>
<html>
    <head>
        <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        
        void main() {
            vNormal = normal;
            
            gl_Position =   projectionMatrix * 
                            modelViewMatrix * 
                            vec4(position,1.0);
        }
        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vNormal;
        
        void main() {
            gl_FragColor = vec4(vNormal.x*.5+.5,vNormal.y*.5+.5,vNormal.z*.5+.5,1.0);
        }
        </script>
        <script src="three.min.js"></script>
        <script src="trackball.js"></script>
        <script src="TP4/marching_cube.js"></script>
        <script src="TP4/sphere_implicit.js"></script>
    </head>
    <body>
        <h1>Implicit Surface</h1>
    </body>
</html>
<script>
    
    /*global THREE, sphere*/
    var scene = new THREE.Scene();

    var renderer = new THREE.WebGLRenderer();

    renderer.setSize(screen.width/2, screen.height/2);
    
    document.body.appendChild(renderer.domElement);
    
    var camera = new THREE.PerspectiveCamera(40, screen.width / screen.height, 0.1, 15000);
    camera.position.set(0, 0, 10);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    
    var material = new THREE.ShaderMaterial({
    	vertexShader: document.getElementById( 'vertexShader' ).textContent,
    	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    });
    

    var camControls = new THREE.TrackballControls( camera );
	camControls.rotateSpeed = 5.0;
	camControls.zoomSpeed = 1.2;
	camControls.panSpeed = 0.8;
	camControls.noZoom = false;
	camControls.noPan = false;
	camControls.staticMoving = true;
	camControls.dynamicDampingFactor = 0.3;
	camControls.keys = [ 65, 83, 68 ];
	camControls.addEventListener( 'change', render );
	
	var spheres = [];
	for(var i = 0; i < 3; i++){
	    spheres.push(new sphere(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5,1/5));
	}
	
	var surface = new THREE.Geometry();
	
	const cube = [[0, 0, 0],
	              [1, 0, 0],
	              [1, 1, 0],
	              [0, 1, 0],
	              [0, 0, 1],
	              [1, 0, 1],
	              [1, 1, 1],
	              [0, 1, 1]];
	
	const edges = [[0.5, 0, 0],
	              [1, 0.5, 0],
	              [0.5, 1, 0],
	              [0, 0.5, 0],
	              [0.5, 0, 1],
	              [1, 0.5, 1],
	              [0.5, 1, 1],
	              [0, 0.5, 1],
	              [0, 0, 0.5],
	              [1, 0, 0.5],
	              [1, 1, 0.5],
	              [0, 1, 0.5]];
	              
    const res = 10;
    
    function marchingcube(){
        var dec = 0;
        
        var vertices = [];
    	var faces = [];
        
        for ( var x = -res; x < res + 1; x ++ ) {
            for ( var y = -res; y < res + 1; y ++ ) {
                for ( var z = -res; z < res + 1; z ++ ) {
                    var bitwise = 0;
                    for(var c = 0; c < cube.length; c++){
                        var value = 0;
                        for(var k in spheres){
                            value += spheres[k].distance(x/res+cube[c][0]/res,y/res+cube[c][1]/res,z/res+cube[c][2]/res);
                        }
                        if(value<0.5){
                            bitwise |= (1 << c);
                        }
                    }
                    //treat bitwise
                    if(bitwise > 0 && bitwise < 255){
                        for(var c = 0; c < edges.length; c++){
                            vertices.push(new THREE.Vector3(x/res+edges[c][0]/res,y/res+edges[c][1]/res,z/res+edges[c][2]/res));
                        }
                        var i = 0;
                        while ( THREE.triTable[bitwise][i] != -1 && i<16 ) {
                            faces.push(new THREE.Face3(THREE.triTable[bitwise][i]+dec, THREE.triTable[bitwise][i+1]+dec, THREE.triTable[bitwise][i+2]+dec));
                    		i += 3;
                    	}
                    	dec += 12;
                    }
                }
            }
        }
        
        surface.vertices =  vertices;
        surface.faces = faces;
        surface.computeFaceNormals();
    }
    
    marchingcube();
    
    var material = new THREE.ShaderMaterial({
    	vertexShader: document.getElementById( 'vertexShader' ).textContent,
    	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    });
    
    var object = new THREE.Mesh( surface, material );
    scene.add(object);
	
	function updateSphere(time){
	    surface.elementsNeedUpdate = true;
	    for(var k in spheres){
	        spheres[k].x = spheres[k].initial_x + Math.cos(k/3 * time)/2;
	        spheres[k].y = spheres[k].initial_y + Math.sin(k/5 * time/3)/2;
	        spheres[k].z = spheres[k].initial_z + Math.cos(k/4 * time/5)/2;
	    }
	    marchingcube();
	}
    
    var clock = new THREE.Clock();
    
    (function animloop(){
      camControls.update(clock.getDelta());
      updateSphere(clock.getElapsedTime());
      render();
      requestAnimationFrame(animloop);
    })();
    
    function render(){
		renderer.render( scene, camera );
    }
</script>