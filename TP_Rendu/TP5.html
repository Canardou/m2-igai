<!DOCTYPE html>
<html>
    <head>
        <script id="vertexShader" type="x-shader/x-vertex">
        varying vec3 vNormal;
        
        void main() {
            vNormal = normal;
            
            gl_Position =   projectionMatrix * 
                            modelViewMatrix * 
                            vec4(position,1.0);
        }
        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vNormal;
        
        void main() {
            gl_FragColor = vec4(vNormal.x*.5+.5,vNormal.y*.5+.5,vNormal.z*.5+.5,1.0);
        }
        </script>
        <script src="three.min.js"></script>
        <script src="trackball.js"></script>
        <script src="TP5/marching_cube.js"></script>
        <script src="TP5/sphere_implicit.js"></script>
    </head>
    <body>
        <h1>Implicit Surface</h1>
    </body>
</html>
<script>
    
    /*global THREE, sphere*/
    var scene = new THREE.Scene();

    var renderer = new THREE.WebGLRenderer();

    renderer.setSize(screen.width/2, screen.height/2);
    
    document.body.appendChild(renderer.domElement);
    
    var camera = new THREE.PerspectiveCamera(40, screen.width / screen.height, 0.1, 15000);
    camera.position.set(0, 0, 4);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    
    var material = new THREE.ShaderMaterial({
    	vertexShader: document.getElementById( 'vertexShader' ).textContent,
    	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    });
    

    var camControls = new THREE.TrackballControls( camera );
	camControls.rotateSpeed = 5.0;
	camControls.zoomSpeed = 1.2;
	camControls.panSpeed = 0.8;
	camControls.noZoom = false;
	camControls.noPan = false;
	camControls.staticMoving = true;
	camControls.dynamicDampingFactor = 0.3;
	camControls.keys = [ 65, 83, 68 ];
	camControls.addEventListener( 'change', render );
	
	var spheres = [];
	for(var i = 0; i < 5; i++){
	    spheres.push(new sphere(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5,1/5));
	}
	
	var inside = new THREE.Geometry();
	var outside = new THREE.Geometry();

    const res = 10;
    for ( var x = -res; x < res; x ++ ) {
        for ( var y = -res; y < res; y ++ ) {
            for ( var z = -res; z < res; z ++ ) {
                var vect = new THREE.Vector3(x/res,y/res,z/res);
                var value = 0;
                for(var k in spheres){
                    value += spheres[k].distance(x/res,y/res,z/res);
                }
                if(value>0.5)
                    inside.vertices.push( vect );
                
                //else
                //    outside.vertices.push( vect );
            }
        }
        console.log(value)
    }

    var outsideMat = new THREE.PointsMaterial( { size:1/res, color: 0x555555 } );
    var insideMat = new THREE.PointsMaterial( { size:1/res, color: 0x55FF55 } );
    
    var insideObj = new THREE.Points( inside, insideMat );
    var outsideObj = new THREE.Points( outside, outsideMat );
    
    scene.add( insideObj );
    scene.add( outsideObj );
	
    
    var clock = new THREE.Clock();
    
    (function animloop(){
      requestAnimationFrame(animloop);
      camControls.update(clock.getDelta());
      render();
    })();
    
    function render(){
		renderer.render( scene, camera );
    }
</script>